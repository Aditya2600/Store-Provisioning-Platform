# Urumi Store Platform - Demo Video Script

## 0:00 - Introduction & System Design
**[Visual: Show System Architecture Diagram or simple slide with: Dashboard -> API -> Operator -> Kubernetes]**

"Hi! I'm [Your Name], and this is the Urumi Store Provisioning Platform.

I've built a Kubernetes-native system that lets you spin up isolated e-commerce stores on demand. The architecture has three main components:
1.  **The Dashboard**: A React UI for managing stores.
2.  **The API**: A FastAPI backend that handles requests.
3.  **The Operator**: A Python-based Kopf controller that listens for 'Store' Custom Resources and creates the actual Kubernetes infrastructure.

Let's see it in action."

## 0:45 - End-to-End Flow (Create -> Order -> Delete)
**[Visual: Split screen. Left: Dashboard. Right: Terminal running `kubectl get pods -A -w`]**

"I'll start by creating a new store called `fashion-boutique`. I select 'WooCommerce' and hit Launch.

**[Visual: Click 'Launch Store'. Show status changing from 'Provisioning' to 'Ready']**

Under the hood, the API created a `Store` Custom Resource. The Operator picked this up and is now creating a dedicated Namespace, generating secrets, and installing a Helm chart for WordPress.

You can see the status updating in real-time. And... it's Ready."

**[Visual: Click 'Visit Store'. Show the WooCommerce storefront.]**

"The store is live at `fashion-boutique.127.0.0.1.nip.io`. I can browse products, add to cart, and place an order.

**[Visual: Add product to cart, Checkout via COD.]**

Now, if I delete the store..."

**[Visual: Click Delete button in Dashboard.]**

"...the Operator ensures a clean teardown. It uses a **Finalizer** to block deletion until the Helm release is uninstalled and the Namespace is removed. No orphaned resources left behind."

## 2:00 - Isolation, Resources & Reliability
**[Visual: Terminal showing `kubectl get ns`, `kubectl describe resourcequota -n store-fashion-boutique`]**

"Reliability and isolation are built-in.
- **Isolation**: Every store lives in its own Namespace. This means valid PVCs, Secrets, and Services are scoped strictly to that tenant.
- **Guardrails**: I've applied ResourceQuotas and Limit Ranges to every namespace. A single store cannot consume all the cluster's CPU or memory.
- **Idempotency**: The operator is idempotent. If the Operator restarts or crashes, it simply reconciles the state again. It won't accidentally duplicate stores."

## 3:00 - Security Posture
**[Visual: Show `secrets` in terminal, show RBAC yaml code]**

"For security:
- **Secrets**: Admin passwords are generated by the operator and stored as Kubernetes Secrets inside the store's namespace. They are never exposed in the CR status or the API responses.
- **RBAC**: The Operator runs with Least Privilege. It can only manage specific resources like Deployments and Services, and mostly within the namespaces it owns.
- **Hardening**: We use NetworkPolicies (deny-by-default) to prevent stores from talking to each other or the platform control plane."

## 4:00 - Horizontal Scaling
**[Visual: Show `charts/platform/values.yaml` replica counts]**

"Scaling this platform is straightforward:
- **Stateless Components**: The API and Dashboard are stateless and can scale horizontally (`replicas: 2+`).
- **The Orchestrator**: The Kopf operator can run with multiple workers to handle many provisioning events in parallel.
- **Throughput**: Since provisioning is IO-bound (waiting for Helm), we can increase the operator's worker threads to provision dozens of stores simultaneously without blocking."

## 5:00 - Abuse Prevention
**[Visual: Show API code `rate_limit` middleware or config]**

"To prevent abuse:
- **Rate Limiting**: Users can only create X stores per minute.
- **Quotas**: We enforce a hard limit on the max active stores per user IP.
- **Blast Radius**: By enforcing ResourceQuotas on each namespace, even if a store gets compromised or DDOS'd, it's contained within its own resource slice."

## 6:00 - Local-to-VPS Production Story
**[Visual: Diff `values-local.yaml` vs `values-prod.yaml`]**

"Finally, moving this to production is seamless because it's all Helm-based.
The only difference between my local setup and a VPS is the **Values File**.

- **Local**: We use `nip.io` for DNS, `hostPath` for storage, and local Docker images.
- **Production**:
    - **Ingress**: Switch to Nginx with Let's Encrypt for real HTTPS.
    - **DNS**: Use ExternalDNS to map real domains.
    - **Storage**: Use a CSI driver like EBS or Longhorn for persistent volumes.
    - **Secrets**: We'd integrate with Vault or AWS Secrets Manager.

Upgrades are just a `helm upgrade`. Rollbacks are a `helm rollback`. Simple, standard, and robust."

**[Visual: Camera or Platform Logo]**

"That's the Urumi Store Platform. Thank you!"
